## 问题描述

一棵树 (也就是一个连通无回路图)，树的结点用整数 $1, …, N$ 编号。 树的Prufer码构造如下：取具有最小的编号的树叶（仅和一条边关联的结点），将该树叶和它所关联的边从图中删除，并记下关联于该树叶的结点的编号。在获取的图中重复这一过程，直到只有一个结点留了下来。很明显，这个唯一留下的结点编号为 $N$。被记下的 $N−1$ 个数的序列被称为树的Prufer码。

给出Prufer码，请重构一棵树。树表示如下：

T ::= "(" N S ")"
S ::= " " T S | empty
N ::= number

即，树用括号把它们括起来，用数字表示其根节点的标识符，后面跟用一个空格分开的任意多的子树（也可能没有）。下图中的树是样例输入中的第一行给出的测试用例。

![](/upload/image/20180104/20180104111216_49345.png)

要注意的是，按上述定义，树的根也可能是树叶。这仅用于我们指定某个节点为树根的情况。通常，我们这里处理的树被称为“无根树”。

## 输入格式

输入包含若干个测试用例，每个测试用例一行，给出一棵树的Prufer码。给出用空格分开的 $n-1$ 个数，输入以EOF结束。设定 $1\leq n\leq 50$。

## 输出格式

对每个测试用例，输出一行，以上述的形式表示相应的树。表示一棵树有多种方式表示：选择你喜欢的一种。

```input1
5 2 5 2 6 2 8
2 3
2 1 6 2 6
```

```output1
(8 (2 (3) (5 (1) (4)) (6 (7))))
(3 (2 (1)))
(6 (1 (4)) (2 (3) (5)))
```



