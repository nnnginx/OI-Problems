## 题目描述

你看中的调试器将不会在这件事上帮助你。有代码可以通过多种方式在调试与正式发布的间隙发生不同的行为，当出现这种情况，我们可能不得不求助于更原始的调试方式。 

  所以，你和你的 `printf` 现在在寻求一行导致该发布版本崩溃的代码。幸运的是：增加 `printf` 语句到程序里，既不会制造 bug（仍然崩溃在同一原始的代码行），也没有影响执行时间（至少不显著）。 因此，即使在每行前加一个 `printf` 语句，运行程序，直到它崩溃，并检查最后打印行。  
  
  然而，它需要一些时间来添加每个 `printf` 语句到代码，并且该程序可以具有很多行。因此，把一个 `printf` 语句在程序的中间或许是一个更好的计划，让它运行，观察它是否在加入行前崩溃，然后继续在代码的前一或后一半寻找。  
不过话又说回来，运行程序可能需要很多时间，所以时效最优的策略可能是介于两者之间。

  编写计算最坏情况下的最小时间来寻找崩溃行（无论它在哪里），认为你选择最优的加 `printf` 语句策略。
我们在 $5$ 小时内发布新的版本，所以这个问题十分严重，需要尽快解决。

## 输入格式

输入包括一行三个整数：  
+ $n$，代码行的数目。
+ $r$，编译和运行程序直到它崩溃的时间量。
+ $p$，增加单个的 `printf` 行所花费的时间。  
您已经运行一次程序，因此已经知道它崩溃的地方。

## 输出格式

输出的最坏情况使用最优策略找到崩溃行的时间。

```input1
1 100 20
```

```output1
0
```

```input2
10 10 1
```

```output2
19
```

```input3
16 1 10
```

```output3
44
```

## 数据规模与约定

对于 $100 \%$ 的数据，$1 \le n \le 10^6$，$1 \le r \le 10^9$，$1 \le p \le 10^9$。