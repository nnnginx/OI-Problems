## 题目描述
[problemUrl]: https://atcoder.jp/contests/abc223/tasks/abc223_b

空でない文字列にし、先^の文字を末尾に移婴工氩僮鳏**左シフト**、末尾の文字を先^に移婴工氩僮鳏**右シフト**と呼びます。

例えば、`abcde` にして左シフトを $ 1 $ 回行うと `bcdea` となり、右シフトを $ 2 $ 回行うと `deabc` となります。

英小文字からなる空でない文字列 $ S $ が与えられます。$ S $ にし左シフトと右シフトをそれぞれ好きな回数（$ 0 $ 回でもよい）行って得られる文字列のうち、辞で最小のものと最大のものを求めてください。

 辞とは？ 辞とはgにh明すると「gZが辞にdっている番」を意味します。より密なh明として、英小文字からなる相なる文字列 $ S,\ T $ の大小を判定するアルゴリズムを以下にh明します。

以下では「 $ S $ の $ i $ 文字目の文字」を $ S_i $ のように表します。また、 $ S $ が $ T $ より辞で小さい龊悉 $ S\ \lt\ T $ 、大きい龊悉 $ S\ \gt\ T $ と表します。

1. $ S,\ T $ のうちLさが大きくない方の文字列のLさを $ L $ とします。$ i=1,2,\dots,L $ にして $ S_i $ と $ T_i $ が一致するか{べます。
2. $ S_i\ \neq\ T_i $ である $ i $ が存在する龊稀そのような $ i $ のうち最小のものを $ j $ とします。そして、$ S_j $ と $ T_j $ を比^して、$ S_j $ が $ T_j $ よりアルファベットで小さい龊悉 $ S\ \lt\ T $ 、そうでない龊悉 $ S\ \gt\ T $ とQ定して、アルゴリズムをK了します。
3. $ S_i\ \neq\ T_i $ である $ i $ が存在しない龊稀$ S $ と $ T $ のLさを比^して、$ S $ が $ T $ より短い龊悉 $ S\ \lt\ T $ 、Lい龊悉 $ S\ \gt\ T $ とQ定して、アルゴリズムをK了します。

## 输入格式
入力は以下の形式で嗜肓Δら与えられる。

> $ S $

## 输出格式
$ 2 $ 行にわたって出力せよ。$ S $ にし左シフトと右シフトをそれぞれ好きな回数（$ 0 $ 回でもよい）行って得られる文字列のうち、辞で最小のものと最大のものをそれぞれ $ S_{\min},\ S_{\max} $ とおいたとき、$ 1 $ 行目には $ S_{\min} $ を、$ 2 $ 行目には $ S_{\max} $ を出力せよ。

## 题目大意
对于非空字符串，将第一个字符移到末尾的操作称为**左移**，将末尾字符移到开头的操作称为**右移**。请在将输入的字符串 $s$ 左移若干次和右移若干次的字符串中找到字典序最小和最大的字符串并依次输出。

```input1
aaba
```

```output1
aaab
baaa
```

```input2
z
```

```output2
z
z
```

```input3
abracadabra
```

```output3
aabracadabr
racadabraab
```

## 提示
### 制s

- $ S $ は英小文字からなる。
- $ S $ のLさは $ 1 $ 以上 $ 1000 $ 以下である。

### Sample Explanation 1

操作によって、`aaab` $ , $ `aaba` $ , $ `abaa` $ , $ `baaa` の $ 4 $ 通りの文字列を得ることができます。 これらのうち辞で最小、最大のものはそれぞれ `aaab` $ , $ `baaa` です。

### Sample Explanation 2

どのように操作を行っても、得られる文字列は `z` のみです。

