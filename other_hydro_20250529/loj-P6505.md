## 题目描述

> 与 Kara 一样，型号为 RK200 的 Markus 也有了自我意识，还成了觉醒仿生人们的领袖  
> 政府对这些异常仿生人没有好感，决定派军队进行清理  
> 而在仿生人这边，也在为应对军队突袭做准备

现在 Markus 手下有 $n$ 个异常仿生人，每个人有一个能力值 $a_i$，现在 Markus 需要带领其中的一部分仿生人建立防御措施。

能力相近的仿生人一起行动能带来很多便利，因此 Markus 带领的这队人中，任意两人的能力值之差不能超过 $k$。

同时，由于建立防御是当前首要的任务，所以能组织越多人，Markus 这边的胜算就越多。试求最多能组织多少。

**数据保证答案会严格超过 $\cfrac{n}{2}$**。

由于空间限制为 $\texttt{1 MiB}$，你无法存储所有的 $a_i$。作为补偿，你可以多次读入数据，但是次数有一定的限制。因此，本题为交互题。

## 任务介绍

我们准备了一个交互库 `find.h`。你需要实现一个函数：`int solve(int n, int k, int inputTimesLimit)`，其中 $n$ 表示人数，$k$ 如题面所示，$\mathit{inputTimesLimit}$ 表示输入次数的限制。你的 `solve` 函数应当返回一个整数，表示你认为的答案。

你可以调用以下两个函数来模拟输入：

- `inputStart()`：调用这个函数表示你申明现在开始新一轮的输入，并把输入位置 $pos$ 赋值为 $0$。
- `getNumber()`：调用这个函数表示你需要读入本轮输入中的下一个数字，这个函数会先把 $pos$ 赋值为 $pos+1$，然后返回 $a_{pos}$，一个 `int` 值，如果 $pos$ 在本次调用后数值等于 $n$，那么本轮输入结束。

注意在上一轮输入还没有结束前调用 `inputStart()` 是非法的，同时这个函数最多只能调用 $\mathit{inputTimesLimit}$ 次。

注意在程序刚刚开始时或者在上一轮输入已经结束后，在未经调用 `inputStart()` 函数申明开始下一轮输入之前调用 `getNumber()` 也是非法的。

## 实现方法

你需要在代码中包含 `find.h` 头文件，并实现 `solve()` 函数。你需要遵循下面的命名和接口

```cpp
int solve(int n, int k, int inputTimesLimit);
void inputStart();
int getNumber();
```

```input1
10 2 23333
4 3 1 2 3 3 5 6 7 4

```

```output1
6

```

## 数据范围

对于 $10\%$ 的数据，$n\le 1$。

对于另外 $20\%$ 的数据，$\mathit{inputTimesLimit}\ge 40$。

对于另外 $30\%$ 的数据，$k=0$。

对于 $100\%$ 的数据满足 $n\le 10^6,0\le k\le 9,\mathit{inputTimesLimit}\ge 2$。

