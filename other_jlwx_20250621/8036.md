## Description

<p>给定一个大小为 n 的树，它共有 n 个结点与 n-1 条边，结点编号从 1 到 n，初始时每个结点上都有一个 1 到 n 的数字，且每个 1 到 n 的数字都只在恰好一个结点上出现。</p><p>接下来你需要进行恰好 n-1 次删边操作，每次操作你需要选择一条未被删去的边，此时这条边所连接的两个结点上的数字将会交换，然后这条边将被删去。</p><p>n-1 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 1 到 n 所在的节点编号一次排列，就得到一个结点编号的排列 Pi 。现在请你求出，在最优操作方案下能得到的字典序最小的 Pi。</p>

## Input Format

<p>输入包含多组测试数据，第一行包含一个正整数 T，表示数据组数。对于每组测试数据：</p><p>第一行包含一个正整数 n，表示树的大小。</p><p>第二行包含 n 个整数，第 i 个整数表示数字 i 初始时所在的节点编号。</p><p>接下来的 n-1 行每行两个整数</p>

## Output Format

<p><span style="color: rgba(0, 0, 0, 0.85);">对于每组测试数据，输出一行共</span><span style="color: rgba(0, 0, 0, 0.85);">n<span></span>n</span><span style="color: rgba(0, 0, 0, 0.85);">个用空格隔开的整数，表示最优操作方案下所能得到的字典序最小的</span><span style="color: rgba(0, 0, 0, 0.85);">P_i<span></span>P<span></span>i​<span></span></span><span style="color: rgba(0, 0, 0, 0.85);">。</span><br /></p>

```input1
4
5
2 1 3 5 4
1 3
1 4
2 4
4 5
5
3 4 2 1 5
1 2
2 3
3 4
4 5
5
1 2 5 3 4
1 2
1 3
1 4
1 5
10
1 2 3 4 5 7 8 9 10 6
1 2
1 3
1 4
1 5
5 6
6 7
7 8
8 9
9 10
```
```output1
1 3 4 2 5
1 3 5 2 4
2 3 1 4 5
2 3 4 5 6 1 7 8 9 10
```
## Hint

<p><img alt="22.PNG" src="/public/upload/d74b6231a3.png" width="461" height="403" /><br /></p>
