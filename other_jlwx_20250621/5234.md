C++ 七级 2024 年 06 月

1 单选题（每题 2 分，共 30 分） 第 1 题 下列C++代码的输出结果是（ ）。

    #include <iostream>
    #include <cmath>
    using namespace std;
    int main() {
        cout << sin(3.1415926 / 2);
        return 0;
    }
    

{{ select(1) }}

*   0
*   1
*   0.5
*   0.7071

第 2 题 对于如下图的二叉树，说法正确的是（ ）。

![image](./5234/file/n3t9-grQ6dfJ3tb5Gl_WB.png)

{{ select(2) }}

*   先序遍历是 `132` 。
*   中序遍历是 `123` 。
*   后序遍历是 `312` 。
*   先序遍历和后序遍历正好是相反的。

第 3 题 已知两个序列`s1= {1,3,4,5,6,7,7,8,1} 、s2= {3,5,7,4,8,2,9,5,1}` ，则它们的最长公共子序列是（）。

{{ select(3) }}

*   `{3,5,7,8,1}`
*   `{3,4,5,7,8}`
*   `{5,7,8}`
*   `{3,5,7,9,1}`

第 4 题 关于序列 `{2,7,1,5,6,4,3,8,9}` ，以下说法错误的是（ ）。

{{ select(4) }}

*   `{2,5,6,8,9}` 是它的最长上升子序列
*   `{1,5,6,8,9}` 是它的最长上升子序列
*   `{7,5,4,3}` 是它的最长下降子序列
*   `{1,5,6,8,9}` 是它的唯一最长上升子序列

第 5 题 关于图的深度优先搜索和广度优先搜索，下列说法错误的是（ ）。

{{ select(5) }}

*   二叉树是也是一种图。
*   二叉树的前序遍历和后序遍历都是深度优先搜索的一种。
*   深度优先搜索可以从任意根节点开始。
*   二叉树的后序遍历也是广度优先搜索的一种。

第 6 题 对于如下二叉树，下面访问顺序说法错误的是（ ）。

![image](./5234/file/CfowobK3Jw0I4bNVYhh_1.png)

{{ select(6) }}

*   HDEBFIGCA不是它的后序遍历序列
*   ABCDEFGHI是它的广度优先遍历序列
*   ABDHECFGI是它的深度优先遍历序列
*   ABDHECFGI是它的先序遍历序列

第 7 题 以下哪个方案不能合理解决或缓解哈希表冲突（ ）。

{{ select(7) }}

*   丢弃发生冲突的新元素。
*   在每个哈希表项处，使用不同的哈希函数再建立一个哈希表，管理该表项的冲突元素。
*   在每个哈希表项处，建立二叉排序树，管理该表项的冲突元素。
*   使用不同的哈希函数建立额外的哈希表，用来管理所有发生冲突的元素。

第 8 题 在C++中，关于运算符`&`，下面说法正确的是（ ）。

{{ select(8) }}

*   `2 & 3` 的结果是 `true`
*   `011 & 111` 的结果是 `3`
*   `3 & 6` 的结果是 `2`
*   `110 & 101` 的结果是 `4`

第 9 题 下面关于图的说法正确的是（ ）。

{{ select(9) }}

*   在无向图中，环是指至少包含三个不同顶点，并且第一个顶点和最后一个顶点是相同的路径。
*   在有向图中，环是指一个顶点经过至少另一个顶点到自身的路径。
*   在有向图中，如果任意两个顶点之间都存在一条边，则这个图一定是强连通图。
*   在有向图中，所有顶点的入度和出度的总和就是图的边数的两倍。

第 10 题 图的存储和遍历算法，下面说法错误的是（ ）。

{{ select(10) }}

*   图的深度优先搜索和广度优先搜索对有向图和无向图都适用。
*   图的深度优先搜索和二叉树的先序遍历道理是不一样的。
*   图的深度优先搜索需要借助栈来完成。
*   邻接表中，顶点 对应链表中的边结点数目正好是顶点 的度。

第 11 题 如下图所示的邻接表结构，表示的是下列哪个选项中的图？

![image](./5234/file/h2I1nx-vDtrTruQOWGGEz.png)

![image](./5234/file/x5RPUtSLErZ-AMXYqFcso.png) ![image](./5234/file/9FDD25R1_nkgiB8A73pj0.png) ![image](./5234/file/8CBgts899vtev3zGN1F4G.png) ![image](./5234/file/WC0J29iSYl1ZORs6pS67N.png)

{{ select(11) }}

*   图A
*   图B
*   图C
*   图D

第 12 题 如下图所示的邻接矩阵（inf表示无穷大），表示的是下列哪个选项中的图？

![image](./5234/file/Uuv-DrcRxXtEg7XQCENm7.png)

![image](./5234/file/i_cziMmXVvW3BXswBWmu-.png) ![image](./5234/file/WDNWN3Zfq2QdeSSQs8_6e.png) ![image](./5234/file/7VNNifx4TSp85uUmvMAe5.png) ![image](./5234/file/k-J1VVn0qSaX5cnjuH5xB.png)

{{ select(12) }}

*   图A
*   图B
*   图C
*   图D

第 13 题 下面程序的输出为（ ）。

    #include <iostream>
    using namespace std;
    int fib(int n) {
        if (n <= 1)
            return n;
        return fib(n - 1) + fib(n - 2);
    }
    int main() {
        cout << fib(6) << endl;
        return 0;
    }
    

{{ select(13) }}

*   5
*   8
*   13
*   无法正常结束。

第 14 题 下面 `count_triple` 函数的时间复杂度为( )。

    int count_triple(int n) {
        int cnt = 0;
        for (int a = 1; a <= n; a++)
            for (int b = a; a + b <= n; b++) {
                int c = sqrt(a * a + b * b);
                if (a + b + c > n)
                    break;
                if (a * a + b * b == c * c)
                    cnt++;
            }
        return cnt;
    }
    

{{ select(14) }}

*   O(n)O(n)O(n)
*   O(n2)O(n^2)O(n2)
*   O(n3)O(n^3)O(n3)
*   O(n4)O(n^4)O(n4)

第 15 题 下列选项中，哪个可能是下图的深度优先遍历序列（ ）。

![image](./5234/file/zQyL1li2nN159BVHleCsK.png)

{{ select(15) }}

*   1, 3, 7, 5, 4, 2, 6, 8, 9
*   9, 4, 2, 1, 3, 5, 7, 6, 8
*   1, 3, 4, 2, 7, 6, 8, 9, 5
*   9, 7, 6, 8, 4, 2, 1, 5, 3

**2 判断题（每题 2 分，共 20 分）**

第 1 题 C++语言中，表达式 `6 & 5` 的结果类型为 int 、值为 `1` 。

{{ select(16) }}

*   对
*   错

第 2 题 冒泡排序是稳定的排序算法。

{{ select(17) }}

*   对
*   错

第 3 题 唯一分解定理（算术基本定理）指出，每个大于1的自然数都可以唯一地分解成若干个素数的乘积。因此，我们可以很容易的对给定的自然数 n 进行质因数分解，时间复杂度仅为 O(log(n))O(log (n) )O(log(n))。

{{ select(18) }}

*   对
*   错

第 4 题 C++语言中，可以为同一个类定义多个构造函数。

{{ select(19) }}

*   对
*   错

第 5 题 使用 `math.h` 或 `cmath` 头文件中的对数函数，表达式 `log(128)` 的结果类型为 `double` 、值约为 `7.0` 。

{{ select(20) }}

*   对
*   错

第 6 题 一颗 N 层的二叉树，至少有 2N−12^{N-1}2N−1 个节点。

{{ select(21) }}

*   对
*   错

第 7 题 非连通图不能使用广度优先搜索算法进行遍历。

{{ select(22) }}

*   对
*   错

第 8 题 现使用有 N 个表项的哈希表，从 M 个元素中进行查找。该哈希表为解决哈希函数冲突，为每个表项处建立单链表存储冲突元素。其查找操作的最坏情况时间复杂度为 O(M)O(M)O(M)。

{{ select(23) }}

*   对
*   错

第 9 题 动态规划有递推实现和递归实现，对于很多问题，通过记录子问题的解，两种实现的时间复杂度是相同的。

{{ select(24) }}

*   对
*   错

第 10 题 泛洪算法的递归方法容易造成溢出，因此大的二维地图算法中，一般不用递归方法。

{{ select(25) }}

*   对
*   错