24. （完善程序）

（积木游戏）问题：有 n 个小木块排成一排，每个小木块向下的一面涂有红、黄、蓝三种颜色之中的一种（约定：0 表示红色，1 表示黄色，2 表示蓝色）。游戏开始时，要求通过翻看与交换方式对小木块重新排列（翻看的规则为每个小木块只能看一次），最终使相同颜色的木块排列在一起，如下图所示：

![img](./427/file/cspmn1.png)

设计一个翻看与交换的方案，实现上面的要求。

例如，设中间状态如下：

![img](./427/file/cspmn2.png)

此时，从 A 处开始进行翻看交换：

若 A 为红色，则不用交换；

若 A 为蓝色，交换一次，即 A 与 B 交换；

若 A 为黄色，交换两次，即 A 与 B 交换一次，然后 B 与 C 再交换一次；

继续翻看交换下一个积木直到完成排列，游戏结束。

另外，初始状态 A 为第一块积木，B 和 C 均为最后一块积木。

【输入】

第一行为一个正整数 n，表示积木的数量。

第二行为 n 个空格隔开的非负整数，表示初始积木的排列顺序，其中 0 表示红色，1 表示黄色，2 表示蓝色。

【输出】

一行一个整数，表示交换的次数。

注意：如果按照上述规则交换时两个积木的位置重合，那么不需要计入总交换次数。

【样例输入】

10

0 0 1 2 2 0 1 0 0 0

【样例输出】

4

```
#include<bits/stdc++.h>
using namespace std;
int n,cnt,r,b,y;
int a[1010];
void swap(int &a, int &b){
    if(_________________________){
        cnt--;
        return;
    }
    a=a+b; b=a-b; _________________________;
}
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    r=1; b=n; y=n;
    while(_________________________){
        if(a[r]==2){
            swap(a[b],a[r]);
            b--; cnt++;
        } else if(a[r]==1){
            _________________________;
            _________________________;
        } else r++;
    }
    cout<<cnt<<endl;
    return 0;
}
```

① 处应填（    ）。

{{ select(1) }}

- a==b
- *a==*b
- &a==&b
- a&&b

② 处应填（    ）。

{{ select(2) }}

- a=a+b
- a=a-b
- a=b-a
- b=b-a

③ 处应填（    ）。

{{ select(3) }}

- r<b
- r<y
- r<=b
- r<=y

④ 处应填（    ）。

{{ select(4) }}

- swap(a[b],a[r]); swap(a[b],a[y]);
- swap(a[r],a[b]); swap(a[r],a[y]);
- swap(a[y],a[b]); swap(a[y],a[r]);
- swap(a[y],a[r]); swap(a[y],a[b]);

⑤ 处应填（    ）。

{{ select(5) }}

- y--; cnt++;
- y--; cnt+=2;
- r++; y--; cnt+=2;
- b--; y--; cnt+=2;
  

