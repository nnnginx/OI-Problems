# Description
在一个神奇的国度里，有一只编程兔，它每天都写很多的代码，各种编程语言如pascal、c、c++、java、basic等等它都了如指掌，各种算法也都已经滚瓜烂熟了。小花是它的好朋友，经常和它一起玩耍。

某一天，小花给编程兔送来了很多的萝卜。编程兔很开心，决定把它的萝卜和其它的小兔子一起分享。小花共计送来了 n 袋萝卜（编号 1 到 n），每袋里面都有一定数量的萝卜。小兔子共计有 m 只，兔子们都很守规矩，按照编号 1 到 m 依次排好领取萝卜，萝卜按照编号从小到大的顺序依次发放（也就是编号小的兔子领取前面的萝卜，编号大的兔子领取后面的萝卜，萝卜一定要分完，不能有剩余），每只兔子都只能领取连续的若干袋萝卜，每只兔子至少领取一袋萝卜，一袋萝卜也只能分给一只兔子，不能分给两只以上的兔子。

编程兔希望萝卜尽量能分的平均一点（否则小兔子们要不开心的^_^），也就是它希望得到萝卜最多数量的兔子的萝卜要最少。这个问题对于编程兔来说很简单，亲爱的同学们，你们会么？

# Format

## Input
第一行是两个正整数 n 和 m，表示萝卜的袋数和兔子的数量。

第二行是 n 个正整数，表示每袋萝卜的数量。

## Output
输出只有一行一个整数，表示得到萝卜最多的那只兔子最少可以得到的萝卜数量，即让最大值最小。

# Samples

```input1
9 3
1 2 3 4 5 6 7 8 9
```

```output1
17
```
```input2
5 2
3 2 5 4 3
```

```output2
10
```

# Explanation
样例一说明：

样例 1 中，第 1 - 5 袋萝卜分给第一只兔子，总数是 15 个萝卜，第 6 - 7 袋萝卜分给第二只兔子，总数是 13 个萝卜，第 8 - 9 袋萝卜分给第三只兔子，总数是 17 个萝卜，萝卜最多的兔子得了 17 个萝卜，这是最多的兔子得到的最少的情况。如果第 1 - 4 袋分给第一只兔子，共计 10 个萝卜，第 5 - 7 袋分给第二只兔子共计 18 个萝卜，第 8 - 9 袋分给第三只兔子，共计 17 个萝卜，这样最多的兔子得到了 18 个萝卜，比之前的方案大，所以不是最优。

样例二说明：

样例 2 中，第 1 - 3 袋萝卜分给第一只兔子，得到 10 个萝卜，第 4 - 5 袋萝卜分给第二只兔子，得到 7 个萝卜，所以最多的兔子得到了 10 个萝卜，这是最优的情况。

# Limitation
对于 60% 的数据，1 ≤ m ≤ n ≤ 100，每袋萝卜的数量不超过 10。

对于 100% 的数据，1 ≤ m ≤ n ≤ 100000，每袋萝卜的数量不超过 10000。
