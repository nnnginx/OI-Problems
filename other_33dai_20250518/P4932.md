## 题目背景
\_\_stdcall在用Edge玩slay的时候，鼠标会经常失灵，这让她十分痛苦，因此她决定也要让你们感受一下Edge制造的痛苦。

## 题目描述
\_\_stdcall给了你n个点，第i个点有权值x[i]，对于两个点u和v，如果x[u] xor x[v]的结果在二进制表示下有奇数个1，那么在u和v之间连接一个Edge，现在\_\_stdcall想让你求出一共有多少个Edge。

如果你没能成功完成任务，那么\_\_stdcall会让你痛苦一下，你这个测试点就没分了。

## 输入格式
一行六个整数，n，a，b，c，d，x[0]。

n是点的个数，每个点的权值需要用如下的方式生成。

你需要使用a，b，c，d和x[0]生成一个数组x，生成方式是这样的。

$x_i = (ax_{i-1}^2 + bx_{i-1} + c) \mod d$

x[i]就是第i个点的权值，点的标号是1到n。

## 输出格式
输出一个整数，表示一共有多少个Edge。

```input1
8 98 24 20 100 44

```

```output1
12

```

```input2
1000 952537 601907 686180 1000000 673601

```

```output2
249711

```

## 提示
我们用v表示权值中的最大值。

对于前20%的数据，n<=10。

对于前40%的数据，n<=100。

对于前60%的数据，n<=1000。

对于前80%的数据，n<=1e6。

对于前90%的数据，v<=1e6。

对于100%的数据，n<=1e7，v<=1e9。

保证a，b，c，d，x[0]都是int内的非负整数。

