## 题目描述
小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近 他研究起了诗词音律的问题。

在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的：

```cpp
 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   
 1   1  5 5 6 6 5  4 4 3 3 2 2 1  
```
因而可以发现，`1 1 5 5 6 6 5 4 4 3 3 2 2 1`这串音符就成为了研究音律的关键。

小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。 小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 $n$ 个音 符的曲子看做是一个正整数数列 $A[1] \cdots A[n]$，那么目标是求另一个正整数数列 $B[1]…B[n]$， 使得对于任意的 $1≤i<n$ 有 $B[i] ≤B[i+1]$，而且使得 $Ans = Max\{|A[j]-B[j]|,1≤j≤n\}$尽量 小。
小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。


## 输入格式
由于数据规模可能较大，因此采用如下方式生成数据。

每个数据包含 7 个数：$n,S_a,S_b,S_c,S_d,A[1],Mod$，即共有 n 个音符，第一个音符为 A[1]。

生成规则如下： 定义生成函数 $F(x) = S_a*x^3 + S_b*x^2 + S_c*x + S_d$; 那么给出递推公式 $A[i] =( F(A[i-1]) + F(A[i-2]) )\%mod$，此处规定 $A[0] = 0$. 由于中间过程的数可能会特别大，所以要求每一步与 $A$ 中的每个数都对一个给定的数 $Mod$ 取模。


## 输出格式
输出一行，包含一个正整数 $Ans$。


```input1
3 815 6901 3839 178 199 10007 
```

```output1
1334
```

## 提示
【数据范围】

对于 10% 的数据， $n≤3$

对于 20% 的数据,  $n≤10$

对于 30% 的数据,  $n≤100$

对于 50% 的数据,  $n≤1000$

对于 70% 的数据,  $n≤100000$

对于 100% 的数据, $n≤5000000$，$S_a,S_b,S_c,S_d,A[1] ≤10000$，$ Mod≤1000000007 $

【友情提示】

样例中生成的数列为：  199 4568 1901，此时将 4568 修改为 3234,1901 也修改为 3234 即可，代价为 1334。


