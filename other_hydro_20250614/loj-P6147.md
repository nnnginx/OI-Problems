## 题目描述

JOHNKRAM 在和 C_SUNSHINE 玩游戏，他们玩的是一个双人对抗游戏。下面来描述一下这个游戏。

我们先来描述一个原子游戏，它是这样的：

这个游戏有两个玩家，不妨叫他们建造者和破坏者。  
这个游戏一开始有一个金字塔，一个例子如下：

```plain
11
1111
1111111
1111111111
11111111111111111
111111111111111111
```

保证金字塔的下一层比上一层的砖的个数严格多。不妨设最下面的为第一层，最左边的为第一个，那么每个砖可以用一个坐标表示，比如最下层左数第五个的坐标是 $ ( 1,5) $。每层金字塔都可能有一个爆破装置，可以摧毁严格在这层以上的金字塔以及严格在这层以上的爆破装置，一个爆破装置可能是建造者拥有的或者破坏者拥有的。还存在一个毁灭装置。建造者和破坏者轮流操作。建造者的操作在下面两种操作中选择一个：

1. 宣誓对该原子游戏的主权，然后选择一个金字塔的砖 $ (x, y) $，摧毁所有不在 $ (1, 1) \ldots (x, y) $ 的砖块。
2. 选择一个建造者拥有的爆破装置，触发它。

破坏者的操作在下面两种操作中选择一个：

1. 选择一个破坏者拥有的爆破装置，触发它。
2. 触发毁灭装置，摧毁整个金字塔，所有爆破装置和毁灭装置本身。

游戏中还有两点特殊的规定：

1. 当一个原子游戏被宣誓主权时，这个游戏中所有的爆破装置会被摧毁（即建造者不能使用操作 2，破坏者不能使用操作 1）。注意，爆破装置不是砖块。
2. 一次操作至少要摧毁一个砖块。

当一个玩家不能操作时他就失败了。

一个游戏是若干个原子游戏的和，玩家在一些原子游戏中担任建造者，在剩下的游戏中担任破坏者。玩家依然是依次操作，每次操作选择一个原子游戏，然后进行一次原子游戏的操作。

JOHNKRAM 是先手。他想知道如果双方足够聪明，谁会赢。

为了增加这个题目的难度，要求你维护这个游戏,支持在游戏中新增或删除一个原子游戏，每次新增或删除一个原子游戏后都要回答谁会赢。

## 输入格式

我们默认所有操作前游戏是空。  
第一行一个数 $ \text{id} $，表示这个数据的编号，你有可能不需要这个信息。  
第二行一个数 $ T $，表示操作的次数，接下来依次读入 $ T $ 个操作。  
每个操作的第一行两个数 $ \text{type} $ 和 $ n $，$ \text{type} = 0 $，表示这个操作是加入，$ \text{type} = 1 $ 表示这个操作是删除。  

若 $ \text{type} = 0 $：  
$ n $ 表示金字塔的行数。
接下来的一行 $ n $ 个数，第 $ i $ 个表示第 $ i $ 行有几个砖块。  
接下来的一行 $ n $ 个数，第 $ i $ 个数是 $ -1 $ 表示该行没有爆破装置，是 $ 0 $ 表示该行有爆破装置且是破坏者拥有。是 $ 1 $ 表示该行有爆破装置且是建造者拥有。  
接下来一行一个数 $ d $，$ d = 1 $ 表示 JOHNKRAM 在这个原子游戏中是建造者，$ d = 0 $ 表示 JOHNKRAM 在这个原子游戏中是破坏者。  
我们在程序的开始定义变量 `tot = 0`，这个游戏的编号是 `++tot`。

若 $ \text{type} = 1 $：  
$ n $ 表示要被删除的原子游戏的编号，保证不会删除不存在的游戏。

## 输出格式

对于每个操作结束后输出一行。若 JOHNKRAM必胜输出 `JOHNKRAM wins`，否则输出 `JOHNKRAM loses`。

```input1
-1
3

0 10
10 9 8 7 6 5 4 3 2 1
0 0 0 -1 1 0 1 -1 1 0
1

0 5
10 8 6 4 2
0 0 0 0 0
0

1 1
```

```output1
JOHNKRAM loses
JOHNKRAM wins
JOHNKRAM wins
```

## 数据范围与提示

本题一共有 $ 50 $ 组数据，编号为 $ 0 \sim 49 $。  
对于编号为 $ i $ 的数据，保证输入的数字总个数小于等于 $ \text{num}[i / 10], \text{num} = \{50, 300, 15000, 300000, 2000000\} $。  
对于编号形如 $ 10 \times i $ 的数据，保证任何时刻不会存在超过 $ 1 $ 个游戏。  
对于编号形如 $ 10 \times i + 1 $ 的数据，保证任何时刻不会存在超过 $ 2 $ 个游戏。  
对于编号形如 $ 10 \times i + 2 $ 的数据，保证不存在删除游戏的操作。  
对于编号形如 $ 10 \times i + 3 $ 的数据，保证每一层都不存在爆破装置。  
对于编号形如 $ 10 \times i + 4 $ 的数据，保证任何时刻不会存在超过 $ 10 $ 个游戏。  
对于编号形如 $ 10 \times i + 5 $ 的数据，保证任何时刻不会存在超过 $ 100 $ 个游戏。  
对于编号形如 $ 10 \times i + 6 $ 的数据，保证所有爆破装置属于破坏者。  
对于编号形如 $ 10 \times i + 7 $ 的数据，保证所有游戏的金字塔层数不超过 $ 100 $。  
对于编号形如 $ 10 \times i + 8 $ 的数据，保证每一层都存在爆破装置。  
对于所有数据，保证输入的所有数字都在 $ 1000000 $ 以内。  
再说一遍，保证金字塔的下一层比上一层的砖的个数严格多。

