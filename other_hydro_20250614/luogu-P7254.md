## 题目描述
有一种不为人知的乐器，这种乐器有 $S$ 个孔，可以通过十种不同的方式 $(0$ ～ $9)$ 覆盖这些孔来弹奏出 $N$ 个音符。你不能采取除了这 $N$ 个音符以外的孔的覆盖方式。

现在你要弹奏一首乐曲，但是由于这种乐器每两个音符之间不能有超过 $G$ 个孔的覆盖方式不同，所以你可能不得不弹错一些音符。你希望最小化你弹错音符的数目。

## 输入格式
第一行三个整数 $N, S, G\ (0 \le G < S \le 100)$，含义如上文所述。

接下来 $N$ 行，每行一个长度为 $S$ 的字符串（只包含数字），表示弹奏这个音符时孔的覆盖方式。

接下来一行一个整数 $L$，表示乐曲中包含的音符的数目。

最后一行 $L$ 个整数，表示乐曲中音符的编号。

## 输出格式
第一行一个整数，表示你能取到的弹错音符数目的最小值。  

接下来一行 $L$ 个整数，表示你的任意一种构造方案。

```input1
5 4 2
1111
2101
2000
0100
0000
7
1 5 4 5 3 2 1
```

```output1
1
1 2 4 5 3 2 1
```

## 提示
**【样例解释】**

音符 $1$ 和音符 $5$ 在四个孔上的弹奏方式都不同，所以你不能在弹奏完音符 $1$ 后弹奏音符 $5$。

**【数据范围】**

- 对于 $40\%$ 的数据，$L \leq 100$；
- 对于 $65\%$ 的数据，$L \leq 5000$；
- 对于 $100\%$ 的数据，$1 \leq N \leq 100$，$1 \le L \le 10 ^ 5$。

**【说明】**

译自 [BalticOI 2012 Day2 T2. Melody](http://www.boi2012.lv/data/day2/eng/melody.pdf)。

