## 题目背景
翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) C 题。

如果你想让数组问题更难解决，可以在树上解决；如果你想让树的问题更难解决，可以在仙人掌上解决。

## 题目描述
在前几年，就有过人提出了许多关于仙人掌――连通无向图的问题，其中每条边最多属于一个简单的循环。更加直观地说，仙人掌是一棵树的概括，在这棵树上允许有一些环。下面的图片给出了仙人掌的一个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/a44vr6aa.png)

你和 Chloe 在一个仙人掌上玩游戏，你有一株仙人掌，但是淘气的 Chloe 偷偷拿走了一个顶点 $v$，你需要在 $10$ 次以内猜出 $v$，如果你猜到了 $v$，那你就赢了，如果你猜测的是另一个点 $u$，Chloe 会告诉你一个点 $w$，其中 $w$ 到 $v$ 经过的边数严格小于 $u$ 到 $v$。

## 输入格式
首先，第一行给你两个整数 $n$ 和 $m$，其中 $n$ 表示一共有 $n$ 个顶点，图的边由一组边不同的路径表示，$m$ 表示它们的数量。

接下来一行，$m$ 个整数 $k_i$，表示该条路径经过了 $k_i$ 个顶点，然后接下来 $k_i$ 个整数，表示一次经过的路径（不会重复经过点）。输入中的图形是一个仙人掌。每次猜测，程序会返回你一些返回值，如果是 `FOUND`，说明你猜对了，否则是 `GO w`，表示 $w$ 到 $v$ 经过的边数严格小于你猜测的点到 $v$ 的边数。你的程序每次询问要猜测不超过 $10$ 次，如果你猜测的次数 $> 10$ 次，那么你就不通过该测试点。

此外为了避免你是蒙对的，需要进行 $n$ 次询问，每次猜测成功后，你直接进行下一轮询问，询问 $n$ 次完直接退出。

## 输出格式
每次询问，你需要向**标准输出**输出一个整数 $u$，代表你猜测的结果，**然后清空缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

```input1
5 2
5 1 2 3 4 5
2 1 3

FOUND
GO 4
FOUND
GO 2
FOUND
GO 1
FOUND
GO 4
GO 5
FOUND
```

```output1




3
3
4
3
2
3
1
3
4
5
```

## 提示
数据保证 $1 \leq n \leq 500$，$0 \leq m \leq 500$，$1 \leq k_i \leq 500$。

注：为了方便比对，在样例输入输出上加入了一些空行进行对齐，实际输入输出中没有这些空行。

