## 题目描述

Tuple 博士正在为ACM（Advanced Commercial Merchandise）公司开发一个数据挖掘的软件。其中一个子程序是用来处理两个数组的，设两个数组分别为 $P$ 和 $Q$，均含 $N$ 个元素，编号为 $0$ 到 $N-1$。数组 $P$ 是一个带关键字的 hash 表，用来存放需要处理的元素，这些元素对应的数据可以通过数组 $Q$ 找到。  
数组 $P$ 中每个元素的大小为 $Sp$ 字节，数组 $Q$ 中每个元素的大小为 $Sq$ 字节。Tuple 博士希望这个子程序的效率越高越好，因为它是整个软件的关键。但是 $Sp$ 和 $Sq$ 只有等到程序运行的时候才能知道，因此是不可能在编译时优化的。  
我们都知道最直接的寻址方式：  
- 数组 $P$ 的第 $i$ 个元素的地址 $Pofs(i)=Sp \times i$ ——（1）；  
- 数组 $Q$ 的第 $i$ 个元素的地址 $Qofs(i)=Sq \times i$ ——（2）。

但是，乘法运算要比加减法慢得多。可喜的是，Tuple 博士成功地避免了使用乘法运算。在整个软件中，他总是用每个元素的地址 $Pofs(i)$ 代替该元素的序号 $i$。在计算与第 $i$ 个元素相邻的元素地址时，只要用下面这两个简单的公式即可：  
$Pofs(i+1)=Pofs(i)+Sp$；  
$Pofs(i-1)=Pofs(i)-Sp$；  
因为 $P$ 和 $Q$ 是一个整体，每当数组 $P$ 中的元素被修改时，$Q$ 中元素也要作相应的变动。$Qofs(i)$ 可以用 $Pofs(i)$ 直接求得：$Qofs(i)=Pofs(i) / Sp \times Sq$ ——（3）。  
然而这个公式不仅要用到乘法，而且要用到除法。虽然仅仅是整数除法，但是速度还是很慢。经过研究，Tuple 博士发现可以用一个更快的公式代替上述公式：$Qofs(i)=(Pofs(i)+Pofs(i)<<A) >>B$ ——（4）。  
其中：$A$ 和 $B$ 是非负整数，`<<A` 表示左移 $A$ 位（相当于乘以 $2^A$），`>>B` 表示右移 $B$ 位（相当于除以 $2^B$）。  
这个公式的效率显然比公式（3）高多了，不过不是总能找到 $A$ 和 $B$ 使之能和公式（3）产生一样的结果的。而且，这个公式可能会牺牲更多的内存。  
如果使用公式（2）的话，存放数组 $Q$ 只需要 $N \times Sq$ 就够了。Tuple 博士发现，如果使用公式（4）的话，总能够找到一个 $K$，用 $K$ 字节存放数组 $Q$ 并恰当地选择 $A$ 和 $B$，使得所有的元素都不重叠。  
任务：请你编写一个程序，找到所有可行的解当中 $K$ 最小的。如果有多组解的话，输出 $A$ 最小的；如果还有多组解，输出 $B$ 最小的。公式的运算过程中可能出现非常大的整数，请你注意不要溢出，不过你不用担心Tuple博士的电脑会溢出。
 
## 输入格式

输入文件中仅一行为三个整数 $N,Sp,Sq$。
 
## 输出格式

输出文件中仅一行为三个整数 $K,A,B$，相邻两个整数之间用一个空格隔开。
 

```input1
20 3 5
```

```output1
119 0 0
```

## 数据规模与约定

$100\%$ 的数据满足：$1 \le N \le 2^{20},1 \le Sp \le 2^{10},1 \le Sq \le 2^{10},K \le N \times Sq$。


