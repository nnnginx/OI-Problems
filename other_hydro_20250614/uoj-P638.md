<p>期末周来临，正值各个课程大作业的危急存亡之秋，蒜斜的电脑坏了：因为一些未知原因，蒜斜存放在内存里的数据经常会损坏，变成随机的乱码。</p>
<p>大作业的 deadline 即将要到了，已经没有时间留给蒜斜去维修、更换电脑了。不过幸运的是，蒜斜电脑的硬盘还是正常的：所有硬盘上的读写操作都是可靠的。</p>
<p>你可以帮蒜斜编写一个能在这台坏掉的电脑上正确运行的高效程序吗？</p>
<h2>B++</h2>
<p>在本题中，你需要使用一个特殊的语言 B++ 来编写程序。</p>
<h4>指令集</h4>
<p>一个 B++ 程序由若干条指令组成。令 $N$ 为程序中指令的数量，$c_0, \dots, c_{N-1}$ 依次表示程序中包含的指令。在一般情况下，B++ 程序会从 $c_0$ 开始，按照编号递增的顺序依次运行。</p>
<p>B++ 包含了如下六种指令：</p>
<ol>
<li><code>Goto v1 v2</code>：读取数据 <code>v1</code> 和 <code>v2</code> 的值，假设分别为 $x,y$。如果 $x \neq 0$，那么程序会跳转到指令 $c_{y}$（即下一条执行的指令会变为 $c_y$）。</li>
<li><code>Move v1 v2</code>：读取数据 <code>v1</code> 的值，并将这个值写入到数据 <code>v2</code>。</li>
<li><code>Calc op v1 v2 v3</code>：读取数据 <code>v1</code> 和 <code>v2</code> 的值 $x$ 和 $y$，并将 $x$ <code>op</code> $y$ 的结果写入到数据 <code>v3</code>。在这条指令中，<code>op</code> 有如下几种选择：<ol>
<li>算数运算符 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>。这些运算的结果与 c++ 中对应的 32 位整数运算完全一致（包括结果溢出的情况）。</li>
<li>逻辑运算符 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>。这些运算的结果与 c++ 中对应的逻辑运算类似：如果 c++ 中结果为真，那么在 B++ 中结果为 $1$，否则为 $0$。</li>
</ol>
</li>
<li><code>Read v</code>：从标准输入中读取一个整数并写入到数据 <code>v</code>。</li>
<li><code>Write v</code>：读取数据 <code>v</code> 的值并输出到标准输出中。</li>
<li><code>Exit</code>：程序运行会立即终止。</li>
</ol>
<p>一个 B++ 程序只有在运行 <code>Exit</code> 指令后才会正常终止。</p>
<h4>数据模型</h4>
<p>B++ 程序在运行的过程中，可以读写两片存储空间 $A$ 和 $B$：它们分别对应着蒜斜电脑的内存和硬盘。在本题中，$A$ 和 $B$ 均可被视为大小为 $10^5$ 的 32 位整数数组：它们合法的下标范围均为 $0$ 到 $99999$，且里面每一个元素的取值范围均为 $[-2^{31},2^{31})$。</p>
<p>在 B++ 中，数据的表示方式如下：</p>
<ol>
<li>任何 32 位的整数 $w$ 都代表了一个常量数据 <code>w</code>：(1) 读取这个数据的结果始终是整数 $w$；(2) 这个数据不能被写入。 </li>
<li><code>r</code> 是一个特殊的数据，它对应着蒜斜电脑上唯一的寄存器：<code>r</code> 可以被视为一个可以读写的全局变量。</li>
<li>对于任意整数 $b \in [-10^5, 10^5]$ 和数据 <code>v</code>，<code>A[b@v]</code> 都是一个数据：对 <code>A[b@v]</code> 读写时，会先读取数据 <code>v</code> 的值 $x$，然后对应地读写 $A_{b+x}$。</li>
<li>对于任意整数 $b \in [-10^5, 10^5]$ 和数据 <code>v</code>，<code>B[b@v]</code> 都是一个数据：对 <code>B[b@v]</code> 读写时，会先读取数据 <code>v</code> 的值 $x$，然后对应地读写 $B_{b+x}$。</li>
</ol>
<p>特别地，当 $b=0$ 时，<code>A[b@v]</code> 和 <code>B[b@v]</code> 可以分别被简写为 <code>A[v]</code> 和 <code>B[v]</code>。 为了改善代码可读性，B++ 规定数据的嵌套层数不能超过 $3$ 层。在这个规定下：</p>
<ol>
<li><code>-114514</code>, <code>A[123]</code>, <code>A[100@B[r]]</code> 都是合法的数据。</li>
<li><code>A[2@B[A[4]]]</code> 不是合法的数据，因为它嵌套了 $4$ 层。</li>
</ol>
<p>令 $U$ 是一个定义在 $[-2^{31},2^{31})$ 中所有整数上的均匀分布，即这个范围内的所有整数出现的概率都是 $2^{-32}$。最开始，$A$ 和 $B$ 中的每个元素以及寄存器 <code>r</code> 都会被赋值为 $U$ 产生的一个随机整数。</p>
<p>就如题目最开始所说的那样，蒜斜电脑的内存坏了，因此数组 $A$ 中的元素会时不时地因为一些未知原因被赋值成随机数。具体来说，在执行完 B++ 的每一条指令之后，$A$ 中的每一个元素都有独立的 $0.01\%$ 的概率被赋值为 $U$ 产生的一个随机整数。</p>
<h4>时间开销</h4>
<p>B++ 程序主要的时间开销在于对数据的读写：执行指令的其他开销都可以被忽略不计。数据读写的开销计算方式如下：</p>
<ol>
<li>读取常量数据 <code>w</code> 的开销为 $0$。</li>
<li>读写寄存器 <code>r</code> 的开销为 $0$。</li>
<li>读写 <code>A[b@v]</code> 的开销都等于读取 <code>v</code> 的开销加 $1$。</li>
<li>读写 <code>B[b@v]</code> 的开销都等于读取 <code>v</code> 的开销加 $100$，因为读写硬盘会比读写内存慢很多。</li>
</ol>
<p>一条指令的开销等于它读写数据的开销总和。举例来说，<code>Goto A[1] B[2]</code> 的开销是 $101$，<code>Calc + A[-2@A[3]] r B[A[1]]</code> 的开销是 $103$，<code>Exit</code> 的开销是 $0$。</p>
<p>B++ 程序运行的总开销等于它执行的所有指令的开销之和。</p>
<h4>运行错误</h4>
<p>B++ 程序主要的运行错误可以分为如下几类：</p>
<ol>
<li>运算错误：在执行 <code>Calc</code> 指令时除以 $0$ 或者对 $0$ 取模。</li>
<li>内存错误：写入了一个常量数据或者试图以小于 $0$ 或者大于等于 $10^5$ 的下标读写 $A$ 或 $B$。</li>
<li>指令错误：尝试执行一条编号小于 $0$ 或者大于等于 $N$ 的指令。</li>
</ol>
<h2>解释器</h2>
<p>为了方便大家本地调试 B++ 程序，本题的下发文件中包含一个解释器 <code>interpreter.cpp</code>。</p>
<h4>使用指南</h4>
<p>你可以使用指令 <code>g++ interpreter.cpp  -o interpreter -std=c++11</code> 来编译下发的解释器。注意，在编译时，你需要把 <code>testlib.h</code> 和 <code>interpreter.cpp</code> 放在同一个文件夹下。</p>
<p>在编译结束后，你可以使用指令 <code>./interpreter inp code oup</code> 来运行解释器，其中 <code>inp</code>, <code>code</code>, <code>oup</code> 分别代表输入文件、B++源码以及输出文件。</p>
<p><code>inp</code> 第一行包含了一个整数 $n$，表示提供给 <code>code</code> 的输入整数数量。接着，第二行包含了 $n$ 个空格隔开的整数，按照顺序表示了 $n$ 个输入整数。</p>
<p><code>oup</code> 第一行包含了一个整数 $m$，表示 <code>code</code> 预期的输出数量。接着，第二行包含了 $m$ 个空格隔开的整数，按照顺序表示了 $m$ 个输出整数。</p>
<p><code>code</code> 第一行包含了一个整数 $N (1 \leq N \leq 10^5)$，表示 B++ 源码包含的指令数。接下来 $N$ 行按照顺序描述了指令 $c_0$ 至 $c_{N-1}$。</p>
<p>解释器会将给定的代码重复运行 $100$ 遍。如果给定的代码在其中任何一次运行的时候出现了运行错误，那么解释器会立即报错并退出。如果始终没有出现运行错误，那么解释器就会统计并输出这 $100$ 遍运行的结果。结果有三种可能性：</p>
<ol>
<li>结果正确 (AC)：代码在 $2 \times 10^5$ 条指令内正常结束了，且输出与 <code>oup</code> 中的输出完全相同。</li>
<li>答案错误 (WA)：代码在 $2 \times 10^5$ 条指令内正常结束了，但是输出与 <code>oup</code> 中的输出不完全一致。</li>
<li>运行超时 (TLE)：在执行了超过 $2 \times 10^5$ 条指令后，代码仍然没有正常结束。</li>
</ol>
<p>解释器的输出格式为 <code>AC: a/100, WA: b/100, TLE: c/100, Max Cost: d</code>，其中 $a,b,c$ 分别表示 $100$ 次运行中结果正确、答案错误和运行超时的出现次数（保证 $a+b+c=100$），$d$ 表示所有结果正确的运行的最大开销。</p>
<p>只有当 $a = 100$ 且 $d \leq 3 \times 10^6$ 的时候，解释器才会认为 <code>code</code> 在 <code>inp</code> 上的运行是正确的。其余情况都会被视为运行错误。</p>
<h4>例子1</h4>
<p>这个例子中的所有内容均包含在下发文件中。这个例子的任务是编写一个 B++ 程序来计算两个输入整数的和：</p>
<ol>
<li>文件 <code>inp1</code> 为 <code>2\n1 2</code>（其中 <code>\n</code> 表示换行符），表示提供给 B++ 程序两个输入 $1$ 和 $2$。</li>
<li>文件 <code>oup1</code> 为 <code>1\n3</code>，表示 B++ 程序的期望输出是一个整数 $3$。</li>
</ol>
<p>下面描述了一个 B++ 程序 (对应文件 <code>code1_1</code>)：</p>
<pre>5
Read B[0]
Read B[1]
Calc + B[0] B[1] B[0]
Write B[0]
Exit</pre><p>因为读写硬盘（数组 $B$）总是可靠的，这个程序保证会输出正确的答案。它的运行开销为 $100+100+300+100 = 600$。下面是解释器给出的结果：</p>
<pre>ok AC: 100/100, WA: 0/100, TLE: 0/100, Max Cost: 600</pre><p>为了加快运行效率，我们可以把计算给转移到内存上（对应文件 <code>code1_2</code>）：</p>
<pre>5
Read A[0]
Read A[1]
Calc + A[0] A[1] A[0]
Write A[0]
Exit</pre><p>这个程序的运行开销减少到了 $1+1+3+1=6$，但是它有可能会输出一个错误答案：因为读写内存（数组 $A$） 是不可靠的。当运行 $c_0, c_1,c_2$ 后 $A_0$ 没有损坏且运行 $c_1$ 后 $A_1$ 没有损坏时，这个程序可以输出正确答案：这个概率为 $(1-0.01\%)^4 \approx 99.96\%$。</p>
<p>但是因为解释器只会将程序重复运行 $100$ 遍，所以在比较大的概率下，解释器仍然会认为这个程序是正确的。下面是解释器可能给出的一个结果：</p>
<pre>ok AC: 100/100, WA: 0/100, TLE: 0/100, Max Cost: 6</pre><h4>例子2</h4>
<p>这个例子中的所有内容均包含在下发文件中。这个例子的任务是编写一个 B++ 程序来计算 $n$ 个输入的和。</p>
<ol>
<li>文件 <code>inp2</code> 为 <code>15\n14 1 2 3 4 5 6 7 8 9 10 11 12 13 14</code>（其中 <code>\n</code> 表示换行符），表示 $n = 14$，且这些数分别为 $1$ 到 $14$。</li>
<li>文件 <code>oup2</code> 为 <code>1\n105</code>，表示 B++ 程序的期望输出是一个整数 $105$。</li>
</ol>
<p>下面描述了一个 B++ 程序 (对应文件 <code>code2_1</code>)：</p>
<pre>8
Read A[0]
Move 0 A[1]
Read A[2]
Calc + A[1] A[2] A[1]
Calc - A[0] 1 A[0]
Goto A[0] 2
Write A[1]
Exit</pre><p>这个程序将 $n$ 读入到 $A_0$ 中，并用 <code>Goto</code> 实现了一个简单的循环。然而，在运行这个程序的时候，解释器可能会报告如下错误：</p>
<pre>FAIL Require too many inputs</pre><p>这是因为在运行的过程中，循环变量 $A_0$ 可能会损坏：这时循环的次数以及读入的次数可能会超过 $n$。</p>
<p>为了避免这一点，我们可以把循环变量存储到寄存器里（对应文件 <code>code2_2</code>）：</p>
<pre>8
Read r
Move 0 A[1]
Read A[2]
Calc + A[1] A[2] A[1]
Calc - r 1 r
Goto r 2
Write A[1]
Exit</pre><p>这个 B++ 程序就不会出现运行错误了。但是因为 $A_1$ 和 $A_2$ 可能会损坏，所以该程序可能会输出错误的结果。下面是解释器给出的一个可能的结果：</p>
<pre>wrong answer AC: 98/100, WA: 2/100, TLE: 0/100, Max Cost: 58</pre><h2>任务</h2>
<p>你的任务是用 B++ 实现一个最基本的数据结构问题。</p>
<p>给定一个长度为 $n$ 的整数数列 $x_1, \dots, x_n$。你需要处理 $m$ 个操作。操作有两种：</p>
<ol>
<li><code>1 p w</code>，表示给 $x_p$ 加上 $w$。</li>
<li><code>2 l r</code>，表示询问 $x$ 数组上区间 $[l,r]$ 的和。</li>
</ol>
<p>写解释器已经是一个大工程了。因此，为了降低出题人的工作量，在给定 $n,m$ 的情况下，其余输入数据都是按照如下方式随机生成的：</p>
<ol>
<li>$x_i$ 服从 $[0, 10^6]$ 中所有整数上的均匀分布。</li>
<li>每一个操作的类型是从 $\{1,2\}$ 中等概率随机选取的。</li>
<li>对于第一类操作，$p$ 服从 $[1,n]$ 中所有整数上的均匀分布，$w$ 服从 $[0, 10^6]$ 中所有整数上的均匀分布。</li>
<li>对于第二类操作，$(l,r)$ 从所有合法区间（共 $n(n+1)/2$ 个）中等概率随机选取。</li>
</ol>
<h4>输入格式</h4>
<p><strong>注意，这儿给出的是 B++ 程序的输入格式</strong>。</p>
<p>输入的前两个整数 $n,m(n,m \geq 1)$，表示 $x$ 的长度以及操作个数。</p>
<p>接下来 $n$ 个整数 $x_i$，表示 $x$ 中元素的初始值。输入的余下部分依次表述了 $m$ 个操作。</p>
<h4>输出格式</h4>
<p><strong>注意，这儿给出的是 B++ 程序的输出格式</strong>。</p>
<p>对于每一个第二类操作，输出一个整数表示答案。</p>
<h4>样例输入</h4>
<pre>14
3 3 1 2 3 2 1 2 1 2 3 2 2 3

</pre>

<h4>样例输出</h4>
<pre>2
3 8

</pre>

<h2>限制与约定</h2>
<p>重要的事情需要再说一遍。下面是本题中需要留意的参数：</p>
<ol>
<li>存储空间 $A$ 和 $B$ 的下标范围为 $[0, 10^5)$ 中的整数。读写一次 $A$ 中元素的开销是 $1$，读写一次 $B$ 中元素的开销是 $100$。</li>
<li>在每一条指令执行结束后，$A$ 中的每一个元素都会有独立的 $0.01\%$ 的概率被赋值为 $[-2^{31}, 2^{31})$ 中的随机整数。</li>
<li>提交程序至多包含 $10^5$ 条指令，这些指令的编号从 $0$ 开始。</li>
<li>在测试时，对于每组测试数据，提交程序都会被独立地运行 $100$ 遍。一次运行被视为正确的当且仅当：<ol>
<li>提交程序的输出正确。</li>
<li>执行的指令条数不超过 $2 \times 10^5$。</li>
<li>执行的所有指令的总开销不超过 $3\times{10^6}$。</li>
</ol>
</li>
<li>对于一组测试数据，提交程序被视为正确当且仅当 $100$ 次运行都是正确的。</li>
</ol>
<p>在评测每一次提交的时候，评测器都会使用不同的随机种子。因此，同一个程序的多次提交对应结果可能会略有波动。在比赛中，只要有一次提交满足对应的要求即可获得对应的分数，但是请注意<strong>每支队伍在一道题上最多提交 $16$ 次</strong>。</p>
<p><strong>Small Task</strong>: $n \leq 100, m \leq 700$。</p>
<p><strong>Large Task</strong>: $n,m \leq 700$。</p>
<p>保证每一个部分包含的测试数据数量不超过 $25$ 组。</p>
<h2>下载</h2>
<p><a href="./21039/file/attachment.zip">下发文件下载</a></p>
