你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。

列表 `deadends` 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 `target` 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 `-1` 。

**示例 1:**

<pre><strong>输入：</strong>deadends = [&#34;0201&#34;,&#34;0101&#34;,&#34;0102&#34;,&#34;1212&#34;,&#34;2002&#34;], target = &#34;0202&#34;
<strong>输出：</strong>6
<strong>解释：</strong>
可能的移动序列为 &#34;0000&#34; -&gt; &#34;1000&#34; -&gt; &#34;1100&#34; -&gt; &#34;1200&#34; -&gt; &#34;1201&#34; -&gt; &#34;1202&#34; -&gt; &#34;0202&#34;。
注意 &#34;0000&#34; -&gt; &#34;0001&#34; -&gt; &#34;0002&#34; -&gt; &#34;0102&#34; -&gt; &#34;0202&#34; 这样的序列是不能解锁的，
因为当拨动到 &#34;0102&#34; 时这个锁就会被锁定。
</pre>

**示例 2:**

<pre><strong>输入:</strong> deadends = [&#34;8888&#34;], target = &#34;0009&#34;
<strong>输出：</strong>1
<strong>解释：</strong>把最后一位反向旋转一次即可 &#34;0000&#34; -&gt; &#34;0009&#34;。
</pre>

**示例 3:**

<pre><strong>输入:</strong> deadends = [&#34;8887&#34;,&#34;8889&#34;,&#34;8878&#34;,&#34;8898&#34;,&#34;8788&#34;,&#34;8988&#34;,&#34;7888&#34;,&#34;9888&#34;], target = &#34;8888&#34;
<strong>输出：</strong>-1
<strong>解释：</strong>无法旋转到目标数字且不被锁定。
</pre>

**提示：**

* `1 <= deadends.length <= 500`
* `<font face="monospace">deadends[i].length == 4</font>`
* `<font face="monospace">target.length == 4</font>`
* `target` **不在** `deadends` 之中
* `target` 和 `deadends[i]` 仅由若干位数字组成

