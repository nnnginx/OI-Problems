# P1942 词编码

## 题目描述

一个发送机可以通过一条信道发送一些以 $0$ 和 $1$ 组成的单词。在其尽头的接收机可以使用特殊技术恢复到最初的单词。每个单词最初都由 $0$ 和 $1$ 组成。所有的单词最初长度都为 $n$。当穿过信道之后单词可能发生以下几种情况之一：

1. 任意（一个）$0$ 被 $1$ 取代
2. 任意（一个）符号被删除
3. 一个符号（$0$ 或 $1$）被插入到任何位置
4. 不改变

我们知道最初的单词都具有以下性质：有 $1$ 的位置号的总和是 $n+1$ 的倍数，或者是 $0$。

## 输入格式

第一行一个正整数 $n\ (4\le n\le 1000)$。

下面若干行（**不一定是 $\bm n$ 行！**），每行表示一个穿过信道之后的单词，每个单词占一行。

**请读入到输入文件末尾：**

- 对于 C++ 的 `std::cin`，可以使用 `while (std::cin >> s) {/* ... */}` 来实现这一功能，其中 `s` 是 `std::string` 类型的变量。
- 对于 C/C++ 的 `scanf`，可以使用 `while (scanf("%s", s) == 1) {/* ... */}` 来实现这一功能，其中 `s` 是 `char*` 类型的变量。
- 对于其他输入函数实现这一功能的方式，请自行查阅文档。

保证单词数不大于 $2001$。

## 输出格式

你的程序应该打印输出原始序列的词，注意换行。

若有多解，请按以下顺序确定最优解，并输出最优解：

- 按照操作 $4$ $\to$ 操作 $1$ $\to$ 操作 $2$ $\to$ 操作 $3$ 的顺序确定最优解
- 同一操作中，按操作位置从左到右的顺序确定最优解
- 对于插入到同一位置的操作 $3$，按插入 $0$ 比插入 $1$ 更优

如果无解则输出 $-1$。

## 输入输出样例 #1

### 输入 #1

```
4
0000
011
1011
11011
```

### 输出 #1

```
0000
0110
1001
1111
```