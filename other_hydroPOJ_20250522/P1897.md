<h2>Description</h2><p>Dr. Tuple is working on the new data-mining application for Advanced Commercial Merchandise Inc. One of the subroutines for this application works with two arrays P and Q containing N records of data each (records are numbered from 0 to N - 1). Array P contains hash-like structure with keys. Array P is used to locate records for processing and the data for the corresponding record is later retrieved from the array Q. 
</p>
All records in array P have a size of S<sub>P</sub><p> bytes and records in array Q have size of S</p><sub>Q</sub><p> bytes. Dr. Tuple needs to implement this subroutine with the highest possible performance because it is a hot-spot of the whole data-mining application. However, S</p><sub>P</sub><p> and S</p><sub>Q</sub><p> are only known at run-time of application which complicates or makes impossible to make certain well-known compile-time optimizations. 
</p>
The straightforward way to find byte-offset of i-th record in array P is to use the following formula: 
<center>Pofs(i) = S<sub>P</sub> * i,       (1)</center><p>
</p>and the following formula for array Q: 
<center>Qofs(i) = S<sub>Q</sub> * i.       (2)</center><p>
</p>However, multiplication computes much slower than addition or subtraction in modern processors. Dr. Tuple avoids usage of multiplication while scanning array P by keeping computed byte-offset Pofs(i) of i-th record instead of its index i in all other data-structures of data-mining application. He uses the following simple formulae when he needs to compute byte-offset of the record that precedes or follows i-th record in array P: 
<center>Pofs(i + 1) = Pofs(i) + S<sub>P</sub>
<br>Pofs(i - 1) = Pofs(i) - S<sub>P</sub></center><p>
</p>Whenever a record from array P is located by either scanning of the array or by taking Pofs(i) from other data structures, Dr. Tuple needs to retrieve information from the corresponding record in array Q. To access record in array Q its byte-offset Qofs(i) needs to be computed. One can immediately derive formula to compute Qofs(i) with known Pofs(i) from formulae (1) and (2): 
<center>Qofs(i) = Pofs(i) / S<sub>P</sub> * S<sub>Q</sub>       (3)</center><p>
</p>Unfortunately, this formula not only contains multiplication, but also contains division. Even though only integer division is required here, it is still an order of magnitude slower than multiplication on modern processors. If coded this way, its computation is going to consume the most of CPU time in data-mining application for ACM Inc. 

After some research Dr. Tuple has discovered that he can replace formula (3) with the following fast formula: 
<center>Qofs'(i) = (Pofs(i) + Pofs(i) &lt;&lt; A) &gt;&gt; B       (4)</center><p>
</p>where A and B are non-negative integer numbers, "&lt;&lt; A" is left shift by A bits (equivalent to integer multiplication by 2<sup>A</sup><p> ), " &gt;&gt; B" is right shift by B bits (equivalent to integer division by 2</p><sup>B</sup><p> ). 
</p>This formula is an order of magnitude faster than (3) to compute, but it generally cannot always produce the same result as (3) regardless of the choice for values of A and B. It still can be used if one is willing to sacrifice some extra memory. 

Conventional layout of array Q in memory (using formula (2)) requires N * S<sub>Q</sub><p> bytes to store the entire array. Dr. Tuple has found that one can always choose such K that if he allocates K bytes of memory for the array Q (where K &gt;= N * S</p><sub>Q</sub><p> ) and carefully selects values for A and B, the fast formula (4) will give non-overlapping storage locations for each of the N records of array Q. 
</p>
Your task is to write a program that finds minimal possible amount of memory K that needs to be allocated for array Q when formula (4) is used. Corresponding values for A and B are also to be found. If multiple pairs of values for A and B give the same minimal amount of memory K, then the pair where A is minimal have to be found, and if there is still several possibilities, the one where B is minimal. You shall assume that integer registers that will be used to compute formula (4) are wide enough so that overflow will never occur. 
<h2>Input</h2><p>The input consists of three integer numbers N , S</p><sub>P</sub><p>, and S</p><sub>Q</sub><p> separated by spaces (1 &lt;= N &lt;= 2</p><sup>20</sup><p>, 1 &lt;= S</p><sub>P</sub><p> &lt;= 2</p><sup>10</sup><p>, 1 &lt;= SQ &lt;= 2</p><sup>10</sup><p>). </p><h2>Output</h2><p>Write to the output file a single line with three integer numbers K, A, and B separated by spaces.</p><pre><code class="language-input1">1024 7 1</code></pre><pre><code class="language-output1">1119 2 5
</code></pre><h2>Source</h2><a href="searchproblem?field=source&amp;key=Northeastern+Europe+2003">Northeastern Europe 2003</a>