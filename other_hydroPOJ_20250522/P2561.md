<h2>Description</h2><p>A (formal) language is a set of strings. One way to define a particular langauge is using ordinary set notation. Alternatively, some form of grammar may be more convenient for representing large sets. The UW grammar in which we are interested has two parts: 
</p><ul><li>An initial string 
<br></li><li>A set of replacement rules of the form s1 -&gt; s2 where s1 and s2 are strings </li></ul><p>
</p>The language defined by this grammar is the set of all strings that can be generated by repeatedly replacing s1 by s2 within the initial string. For example, consider the grammar G consisting of the initial string 

"AyB"

and the replacement rules 
{"A"-&gt;"ab", "Ay"-&gt;"cdy", "B"-&gt;"w", "B"-&gt;"x"} .

G generates the language 

L = {"AyB", "Ayw", "Ayx", "abyB", "abyw", "abyx", "cdyB", "cdyw", "cdyx"}

Given a UW grammar G, compute how many different strings there are in the language generated by G.
<h2>Input</h2><p>The first line of input contains the initial string. The second and subsequent lines contain the replacement rules, one per line, terminated by end-of-file. There are at most 100 replacement rules. Each input string contains between 0 and 10 upper and lower case letters, and is enclosed in quotes. There are no spaces in the input. </p><h2>Output</h2><p>Output consists of a single integer, the number of distinct strings in the language generated by G. If there are more than 1000 distinct strings, print "Too many." instead. </p><pre><code class="language-input1">&quot;AyB&quot;
&quot;A&quot;-&amp;gt;&quot;ab&quot;
&quot;Ay&quot;-&amp;gt;&quot;cdy&quot;
&quot;B&quot;-&amp;gt;&quot;w&quot;
&quot;B&quot;-&amp;gt;&quot;x&quot;
</code></pre><pre><code class="language-output1">9
</code></pre><h2>Source</h2><a href="searchproblem?field=source&amp;key=Waterloo+local+2000.09.23">Waterloo local 2000.09.23</a>