<h2>Description</h2><span lang="en-us"><p>A typical assignment for computer science students is to build a compiler that compiles a simple language for a RISC architecture, which, when it goes to extremes, could become: evaluating an expression on an ultimate RISC architecture – a One Instruction Set Computer (OISC).</p><p><b>Target Architecture</b></p><p>The target architecture has a memory consisting of 65,536 16-bit words and a 16-bit instruction pointer IP. As suggested by its name, it has only one instruction: subtract-and-branch-if-non-negative. In each instruction cycle, the processor reads three consecutive words <i>a</i>, <i>b</i> and <i>c</i> at the address stored in IP, then subtracts <i>a</i> from the word at address <i>b</i>. If the result is non-negative, IP is set to <i>c</i>, otherwise it is increased by three. (Here by “subtract” and “non-negative” we mean 16-bit signed integer arithmetic.) When IP is greater than or equal to 65,534, the processor halts.</p><p>A program is executed as follows:</p><ol><li>The program is loaded into memory starting from address 0.</li><li>A word-sized input parameter is placed at address 0, overwriting the program’s first word.</li><li>IP is set to 0.</li><li>The processor starts execution until it halts.</li><li>The word at address 0 is considered as the output.</li></ol><p><b>Source Language</b></p><p>The source language is an arithmetic expression consisting of only ‘<code>(</code>’, ‘<code>)</code>’, ‘<code>+</code>’, ‘<code>*</code>’, ‘<code>x</code>’ and floating-point constants. ‘<code>x</code>’ represents the input. The expression is supposed to be evaluated in exactly the same manner as its literally specified semantics, i.e., subexpressions in parentheses take highest precedence, followed by multiplication then addition. All constants, intermediate results and the input ‘<code>x</code>’ are rounded to 16-bit half-precision floating point numbers by the round-to-even method. </p><p>Given an expression, your task is to compile it into an OISC program.</p><hr align="left" width="400" size="1"><p><b>A quick reference for half-precision floating point</b> </p><p><i>Memory format</i></p><blockquote><p>Half precision memory format has a sign bit, 5 bits of exponent and 10 bits of mantissa:</p><table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#000000"><tbody><tr><td rowspan="2" valign="top" width="25"><p align="center">bit</p></td><td width="30">15</td><td width="60">14~10</td><td width="60">9~0</td></tr><tr><td width="30">sign</td><td width="60">exponent</td><td width="60">mantissa</td></tr></tbody></table><p>The mathematical value of a half-precision floating point number is (−1)<sup>sign</sup> × <span style="text-decoration: overline">1.mantissa</span> × 2<sup>exponent − 15</sup>. Below are several examples.</p><table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#000000"><tbody><tr><td>Encoding</td><td>Value</td></tr><tr><td>0 01111 000000000</td><td>1</td></tr><tr><td>0 01111 100000000</td><td>1.5</td></tr><tr><td>1 01110 100000000</td><td>−0.75</td></tr></tbody></table><p>Among all possible exponents, 0 and 31 are reserved for representation of special values and not involved in this problem.</p></blockquote><p><i>Rounding convention</i></p><blockquote><p>Rounding is done by the round-to-even method, i.e., an unrepresentable value is rounded to the nearest number unless two possible outcomes are equally near, in which case the one with an even least significant bit is chosen. Below are several examples.</p><table border="1" cellpadding="2" cellspacing="0" style="border-collapse: collapse" bordercolor="#000000"><tbody><tr><td>Decimal</td><td>Binary</td><td>Rounded in half precision</td><td>Rounded in binary</td></tr><tr><td>0.499755859375</td><td>0.0111111111111</td><td>0 01110 0000000000</td><td>0.1</td></tr><tr><td>2.0009765625</td><td>10.0000000001</td><td>0 10000 0000000000</td><td>10</td></tr><tr><td>0.6</td><td>0.10011001…</td><td>0 01110 0011001101</td><td>0.10011001101</td></tr></tbody></table></blockquote><p>Below are two routines written in C for simplified conversions between half-precision and single-precision floating point numbers.</p><p><code>typedef unsigned short half;<br><br>float half_to_float(half h)<br>{<br>&nbsp;&nbsp;&nbsp; unsigned int f;<br>&nbsp;&nbsp;&nbsp; if ((h &amp; 0x7ffff) == 0) return 0;<br>&nbsp;&nbsp;&nbsp; f = ((h &amp; 0x8000) &lt;&lt; 16) /* sign&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + ((h &amp; 0x7fff) &lt;&lt; 13) /* exponent and mantissa */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + ((127 - 15) &lt;&lt; 23);&nbsp; /* adjust exponent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; return *(float*)&amp;f;<br>}<br><br>half float_to_half(float f)<br>{<br>&nbsp;&nbsp;&nbsp; unsigned int u = *(unsigned int*)&amp;f;<br>&nbsp;&nbsp;&nbsp; int e = ((u &gt;&gt; 23) &amp; 0xff) - 127 + 15;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* exponent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; int m = ((u &gt;&gt; 13) &amp; 0x3ff) + ((u &gt;&gt; 12) &amp; 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mantissa rounded half-up */<br>&nbsp;&nbsp;&nbsp; if ((u &amp; 0x1fff) == 0x1000) m &amp;= 0x7fe;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* round to even&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; if (m == 0x400) { m = 0; e++; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* carry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; if (e &lt;= 0) { return (u &gt;&gt; 16) &amp; 0x8000; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* underflow or zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; if (e &gt; 30) { return 0x7bff + ((u &gt;&gt; 16) &amp; 0x8000); } /* overflow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp; return ((u &gt;&gt; 16) &amp; 0x8000) + (e &lt;&lt; 10) + m;<br>}</code></p></span><h2>Input</h2><p>The input is presented as an expression on a single line. The expression can contain up to 8 arithmetic operators.</p><h2>Output</h2><p>The output should be a line of at most 65,536 space-separated integers, each representing a word in the OISC program starting from address 0. Memory unoccupied when the program is loaded will be filled with 0.</p><pre><code class="language-input1">0.499755859375+0.125*(2.0009765625+2)</code></pre><pre><code class="language-output1">0 0 3 -15360 0 65535</code></pre><h2>Hint</h2><p>Underflow, overflow and special values (zeroes, denormals, infinities and NaNs) will not occur in this problem.</p><p>Rounding to single precision before rounding to half precision is always safe in this problem.</p><h2>Source</h2><a href="searchproblem?field=source&amp;key=POJ+Monthly--2007.03.04">POJ Monthly--2007.03.04</a><p>, Hou, Qiming</p>