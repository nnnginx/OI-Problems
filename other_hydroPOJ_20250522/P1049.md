<h2>Description</h2><p>Consider a small microprocessor that has the following properties:
</p>?Each word is four bits.
?Addresses are two words. The high word always comes first. That is, the high word of a two-word address will always occupy the lower word of memory.
?Memory is 256 words.
?There are two accumulators, A and B, each storing one word.
?There are nine instruction codes. Each instruction requires at least one word to store the code that specifies the instruction. Four instructions have arguments and require an additional two words.
Each 4 bit number can have the values from 0 to 15, inclusive, in base 10. We will write these using hexadecimal in the usual way, i.e. A means 10, B means 11, etc.
These are the nine instructions:
<table border="1" width="100%" cellpadding="0" cellspacing="0">  <tbody><tr>    <td width="11%" align="center">Code</td>    <td width="11%" align="center"><b><span lang="EN-US">Words</span></b></td>    <td width="78%"><b><span lang="EN-US">Description</span></b></td>  </tr>  <tr>    <td width="11%" align="center">0</td>    <td width="11%" align="center">3</td>    <td width="78%"><span lang="EN-US">LD: Load accumulator A with the contents       of memory at the specified argument.</span></td>  </tr>  <tr>    <td width="11%" align="center">1</td>    <td width="11%" align="center">3</td>    <td width="78%"><span lang="EN-US">ST: Write the contents of accumulator A       to the memory location specified by the argumen</span></td>  </tr>  <tr>    <td width="11%" align="center">2</td>    <td width="11%" align="center">1</td>    <td width="78%"><span lang="EN-US">SWP: Swap the contents of accumulators A       and B.</span></td>  </tr>  <tr>    <td width="11%" align="center">3</td>    <td width="11%" align="center">1</td>    <td width="78%"><span lang="EN-US">ADD: Add the contents of accumulators A       and B. The low word of the sum is stored in A, and the high word in B</span></td>  </tr>  <tr>    <td width="11%" align="center">4</td>    <td width="11%" align="center">1</td>    <td width="78%"><span lang="EN-US">INC: Increment accumulator A. Overflow is       allowed; that is, incrementing F yields 0.</span></td>  </tr>  <tr>    <td width="11%" align="center">5</td>    <td width="11%" align="center">1</td>    <td width="78%"><span lang="EN-US">DEC: Decrement accumulator A. Underflow       is allowed; that is, decrementing 0 yields F.</span></td>  </tr>  <tr>    <td width="11%" align="center">6</td>    <td width="11%" align="center">3</td>    <td width="78%"><span lang="EN-US">BZ: If accumulator A is zero, the next       command to be executed is at the location specified by the argument. If A       is not zero, the argument is ignored and nothing happens.</span></td>  </tr>  <tr>    <td width="11%" align="center">7</td>    <td width="11%" align="center">3</td>    <td width="78%"><span lang="EN-US">BR: The next command to be executed is at       the location specified by the argument.</span></td>  </tr>  <tr>    <td width="11%" align="center">8</td>    <td width="11%" align="center">1</td>    <td width="78%"><span lang="EN-US">STP: Stop execution of the program.</span></td>  </tr></tbody></table><p>
</p>The microprocessor always begins by executing the command at location 00. It executes the commands in sequence until it reaches the Stop command.
The examples below show partial programs and describe their affect.
<table border="1" cellpadding="0" cellspacing="0" width="100%">  <tbody><tr>    <td width="13%"><span lang="EN-US">Program</span></td>    <td width="87%"><span lang="EN-US">Description</span></td>  </tr>  <tr>    <td width="13%"><span lang="EN-US">01A8</span></td>    <td width="87%"><span lang="EN-US">Load accumulator A with the contents of       memory location 1A (26 in decimal) and stop.</span></td>  </tr>  <tr>    <td width="13%"><span lang="EN-US">01A512F8</span></td>    <td width="87%"><span lang="EN-US">Load accumulator A with the contents of       memory location 1A (26 in decimal), decrement it, store the result to       memory location 2F, then stop.</span></td>  </tr></tbody></table><h2>Input</h2><p>The input will consist of several lines of exactly 256 hex characters. Each line is the contents of memory, beginning with address 00 and ending with address FF. The end of the input is indicated by a memory state that has a stop instruction (an "8") at address 00. The input programs will never "fall of the end of memory" that is, you will never execute an instruction that is located between addresses F0 and FF, inclusive.</p><h2>Output</h2><p>For each memory state, you should simulate execution beginning with address 00. When the stop instruction is reached, you will dump the contents of memory to the output as a single string of 256 hex characters followed by a newline character.</p><pre><code class="language-input1">0102011311321128FF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</code></pre><pre><code class="language-output1">0102011311321128FF1E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</code></pre><h2>Source</h2><a href="searchproblem?field=source&amp;key=Greater+New+York+2001">Greater New York 2001</a>