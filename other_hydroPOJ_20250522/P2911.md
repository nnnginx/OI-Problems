<h2>Description</h2><span lang="en-us"><p>Lambda calculus is the main theoretical core of functional languages. It is based on evaluating <i>λ</i>-expressions.</p><p>A <i>λ</i>-expression is a string of characters consisting either of <i>1)</i> a single constant (for example <i>t</i>), or <i>2)</i> a function definition written as <i>L</i>‹<i>var</i>›.‹<i>body</i>›, where <i>L</i> denotes , ‹<i>var</i>› is always some variable (for example <i>x</i>) that can occur in the ‹<i>body</i>›, which is again some <i>λ</i>-expression, or <i>3)</i> an application of some ‹<i>function</i>› (for example <i>f</i>) to an ‹<i>argument</i>› (for example <i>x</i>), in our case written as (<i>f</i>)<i>x</i>, both ‹<i>function</i>› and ‹<i>argument</i>› are <i>λ</i>-expressions.</p><p>The occurrences of variable ‹<i>var</i>1› in an expression <i>E</i> are called bound, if they are inside of the ‹<i>body</i>› of some sub-expression <i>L</i>‹<i>var</i>1›.‹<i>body</i>› of <i>E</i>. Variable occurrences that are not bound are called unbound.</p><p>Evaluation of <i>λ</i>-expression results in another <i>λ</i>-expression and is performed using the following rules:</p><ol><li>Constant is evaluated to itself,</li><li>Function definition evaluates to itself,</li><li>Function application (‹<i>function</i>›)‹<i>argument</i>› is evaluated as follows: first, the ‹<i>function</i>› is evaluated to <i>L</i>‹<i>var</i>›.‹<i>body</i>› or something else. In the latter case, the ‹<i>argument</i>› is evaluated, and the whole function application evaluates to (‹<i>evaluated function</i>›)‹<i>evaluated argument</i>›. If the ‹<i>function</i>› evaluates to <i>L</i>‹<i>var</i>›.‹<i>body</i>›, the ‹<i>argument</i>› is not evaluated, but all unbound occurrences of variable ‹<i>var</i>› inside of the expression ‹<i>body</i>› are directly replaced by (substituted with) the argument ‹<i>argument</i>›. The result of the whole evaluation of function application is then the evaluated ‹<i>body</i>›, after the substitution was performed.</li></ol><p>We limit the expressions to contain a single-character lowercase (<i>a</i>…<i>z</i>) variables and constants only. Sometimes the evaluation never stops. Your program should perform at most 1000 function applications when evaluating any <i>λ</i>-expression. During all evaluation steps, the evaluated <i>λ</i>-expression will not exceed 10000 characters.</p><p>Here are some examples of evaluation of simple <i>λ</i>-expressions (shown in several steps, the text behind <tt>;</tt> is a comment):</p><blockquote><table><tbody><tr><td valign="top" colspan="3">1.</td></tr><tr><td valign="top" width="10"></td><td valign="top" width="150"><tt>(Lx.x)y<br>y</tt></td><td valign="top"><tt>; x &lt;- y</tt></td></tr><tr height="20"><td colspan="3"></td></tr><tr><td valign="top" colspan="3">2.</td></tr><tr><td valign="top" width="10"></td><td valign="top" width="150"><tt>(((Lx.Ly.q)Lz.t)r)u<br>((Ly.q)r)u<br>(q)u</tt></td><td valign="top"><tt>; x &lt;- Lz.t<br>; y &lt;- r</tt></td></tr></tbody></table></blockquote><p>Note that the scope of the variable next to <i>λ</i> covers only the body of the lambda expression, and the same variable can occur at other places of the expression, for example:</p><blockquote><table><tbody><tr><td valign="top" colspan="2">3.</td></tr><tr><td valign="top" width="10"></td><td valign="top" width="150"><tt>((Lx.x)(Ly.y)Lx.x)x<br>((Ly.y)Lx.x)x<br>(Lx.x)x<br>x</tt></td></tr></tbody></table></blockquote><p>The body of the <i>λ</i>-expression can contain unbound variables - constants:</p><blockquote><table><tbody><tr><td valign="top" colspan="3">4.</td></tr><tr><td valign="top" width="10"></td><td valign="top" width="150"><tt>(((Lx.Ly.q)Lz.t)r)u<br>((Ly.q)r)u<br>q(u)</tt></td><td valign="top"><tt>; x &lt;- Lz.t<br>; y &lt;- r</tt></td></tr></tbody></table></blockquote><p>Finally note that our evaluation is simplified as compared to the real <i>λ</i>-calculus: when the argument is substituted for all unbound occurrences of some variable during function application, some of the variable occurrences in the argument that were previously unbound can become bound… This is normally solved by renaming all the variables in the argument before the function application, and keeping track of correct substitutions. In this problem, you don’t need to take care of this.</p><blockquote><table><tbody><tr><td valign="top" colspan="3">5.</td></tr><tr><td valign="top" width="10"></td><td valign="top" width="150"><tt>((Ly.Lx.y)x)w<br>(Lx.x)w<br>w</tt></td><td valign="top"><tt>; y &lt;- x</tt></td></tr></tbody></table></blockquote><p>The Department of Programming Languages decided to implement a new functional language. However, they first need a core engine that will evaluate <i>λ</i> -expressions. Write a program that will read a set of expressions from the input file and output their evaluations.</p></span><h2>Input</h2><span lang="en-us"><p>The input contains set of <i>λ</i>-expressions, one per line. Only the last line contains the expression consisting of a single constant <i>z</i>. You can assume that the input is correct.</p></span><h2>Output</h2><span lang="en-us"><p>The output should contain the result of evaluation of the expressions on the input in the same order as they appear in the input including the last line. If the expression leads to more than 1000 function applications, the line should contain single word “<tt>unterminated</tt>”.</p></span><pre><code class="language-input1">Lq.q
((Lx.Ly.(x)y)Lz.z)Lq.q
(Lx.x)x
((((Lm.Ln.Lf.Lx.((m)f)((n)f)x)Lo.Lt.(o)t)Lu.Lv.(u)(u)v)a)b
(Lx.(x)x)Lx.(x)x
(q)(Lx.Lx.x)z
z</code></pre><pre><code class="language-output1">Lq.q
Lq.q
x
(a)(a)(a)b
unterminated
(q)Lx.x
z</code></pre><h2>Source</h2><a href="searchproblem?field=source&amp;key=Svenskt+M%C3%A4sterskap+i+Programmering%2FNorgesmesterskapet+2002">Svenskt Mästerskap i Programmering/Norgesmesterskapet 2002</a>